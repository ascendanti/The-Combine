#!/usr/bin/env python3
"""
Telegram Notification Module for Daemon Workers

Import this in any daemon worker to send Telegram updates.

Usage:
    from telegram_notify import notify, notify_progress, notify_error, notify_complete

    # Simple notification
    notify("Processing started")

    # Progress update
    notify_progress("Ingesting book", 50, 100)

    # Error
    notify_error("Failed to process", "File corrupted")

    # Completion
    notify_complete("Book ingested", {"claims": 42, "concepts": 15})

    # LocalAI can send summaries
    notify_localai_summary("Book Title", "Key insights from the book...")
"""

import json
import urllib.request
from typing import Optional, Dict, Any
from datetime import datetime

# Configuration
BOT_TOKEN = "8031397990:AAEr6hUi1XKEJWTM1HLgKTriSfssBAJzLZI"
CHAT_ID = "8266225191"
ENABLED = True  # Set False to disable notifications

def _send(text: str, parse_mode: str = "Markdown") -> bool:
    """Internal send function."""
    if not ENABLED:
        return True

    data = json.dumps({
        "chat_id": CHAT_ID,
        "text": text[:4000],  # Telegram limit
        "parse_mode": parse_mode
    }).encode('utf-8')

    req = urllib.request.Request(
        f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage",
        data=data,
        headers={"Content-Type": "application/json"}
    )

    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            result = json.loads(resp.read())
            return result.get("ok", False)
    except Exception as e:
        print(f"[Telegram] Failed: {e}")
        return False

def notify(message: str, prefix: str = "â„¹ï¸") -> bool:
    """Send a simple notification."""
    return _send(f"{prefix} {message}")

def notify_progress(task: str, current: int, total: int, details: str = "") -> bool:
    """Send progress update with progress bar."""
    pct = int((current / total) * 100) if total > 0 else 0
    bar_filled = int(pct / 10)
    bar = "â–ˆ" * bar_filled + "â–‘" * (10 - bar_filled)

    msg = f"â³ *{task}*\n\n`[{bar}]` {pct}%\n{current}/{total}"
    if details:
        msg += f"\n\n_{details}_"

    return _send(msg)

def notify_error(task: str, error: str, recoverable: bool = True) -> bool:
    """Send error notification."""
    emoji = "âš ï¸" if recoverable else "âŒ"
    msg = f"{emoji} *Error: {task}*\n\n`{error}`"
    if recoverable:
        msg += "\n\n_Will retry..._"
    return _send(msg)

def notify_complete(task: str, stats: Optional[Dict[str, Any]] = None) -> bool:
    """Send completion notification with optional stats."""
    msg = f"âœ… *{task}*"

    if stats:
        msg += "\n\n*Stats:*"
        for key, value in stats.items():
            msg += f"\nâ€¢ {key}: `{value}`"

    return _send(msg)

def notify_localai_summary(title: str, summary: str, source: str = "LocalAI") -> bool:
    """Send a summary generated by LocalAI."""
    msg = f"ðŸ¤– *{source} Summary*\n\n"
    msg += f"ðŸ“„ *{title}*\n\n"
    msg += f"{summary[:3000]}"  # Leave room for formatting

    return _send(msg)

def notify_decision_needed(question: str, options: list = None) -> bool:
    """Ask user for a decision via Telegram."""
    msg = f"ðŸ¤” *Decision Needed*\n\n{question}"

    if options:
        msg += "\n\n*Options:*"
        for i, opt in enumerate(options, 1):
            msg += f"\n{i}. {opt}"
        msg += "\n\n_Reply with option number_"

    return _send(msg)

def notify_worker_status(worker_name: str, status: str, details: Dict = None) -> bool:
    """Report worker status."""
    emoji_map = {
        "started": "ðŸš€",
        "running": "âš™ï¸",
        "stopped": "ðŸ›‘",
        "error": "âŒ",
        "idle": "ðŸ’¤"
    }
    emoji = emoji_map.get(status, "ðŸ“Š")

    msg = f"{emoji} *{worker_name}*: {status}"

    if details:
        msg += "\n"
        for k, v in details.items():
            msg += f"\nâ€¢ {k}: {v}"

    return _send(msg)

def notify_knowledge_update(entity_type: str, count: int, source: str = None) -> bool:
    """Notify about knowledge graph updates."""
    msg = f"ðŸ“š *Knowledge Updated*\n\n"
    msg += f"+{count} {entity_type}"
    if source:
        msg += f"\nFrom: _{source}_"

    return _send(msg)

# Convenience function for quick status
def ping() -> bool:
    """Quick ping to confirm connection."""
    return _send("ðŸ“ Pong - Daemon connected")

# Test if run directly
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        notify(" ".join(sys.argv[1:]))
    else:
        ping()
